% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/decoupleR-decouple.R
\name{.invoke_statistic}
\alias{.invoke_statistic}
\title{Construct an expression to evaluate a decoupleR statistic.}
\usage{
.invoke_statistic(fn, args, mat, network, .source, .target, show_call = FALSE)
}
\arguments{
\item{fn}{Expression containing the name of the function to execute.}

\item{args}{Extra arguments to pass to the statistician under evaluation.}

\item{mat}{Matrix to evaluate (e.g. expression matrix).
Target nodes in rows and conditions in columns.
\code{rownames(mat)} must have at least one intersection with the elements
in \code{network} \code{.target} column.}

\item{network}{Tibble or dataframe with edges and it's associated metadata.}

\item{.source}{Column with source nodes.}

\item{.target}{Column with target nodes.}

\item{show_call}{The call of each statistician must be informed?}
}
\description{
Construct an expression to evaluate a decoupleR statistic.
}
\details{
\code{.invoke_statistic()} was designed because \code{\link[purrr:invoke]{purrr::invoke_map_dfr()}} is retired.
The alternative proposed by the developers by purrr is to use \code{\link[rlang:exec]{rlang::exec()}} in
combination with \code{\link[purrr:map2]{purrr::map2()}}, however, the function is not a quoting function,
so the parameters that require the \code{curly-curly} (\code{{{}}}) operator require a
special pre-processing. In practical terms, creating an expression of zero allows
us to have better control over the function call as suggested in the \code{\link[rlang:exec]{rlang::exec()}}
documentation. For instance, we can see how the function itself is being called.
Therefore, if an error occurs in one of the statistics, we will have a direct
traceback to the problematic call, as opposed to what happens directly using \code{\link[rlang:exec]{rlang::exec()}}.
}
\keyword{internal}
