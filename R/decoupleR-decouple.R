#' decouple
#'
#' Calculate the TF activity per sample out of a gene expression matrix by
#' coupling a regulon network with a variety of statistics.
#'
#' @inheritParams .decoupler_mat_format
#' @inheritParams .decoupler_network_format
#' @param statistics Statistical methods to be coupled.
#' @param .options A list of argument-lists the same length as `statistics` (or length 1).
#'  The default argument, list(NULL), will be recycled to the same length as `statistics`,
#'  and will call each function with no arguments (apart from `mat`,
#'  `network`, `.source` and, `.target`).
#' @param verbose The call of each statistician must be informed?
#'
#' @return A long format tibble of the enrichment scores for each tf
#'  across the samples. Resulting tibble contains the following columns:
#'  1. `statistic`: Indicates which method is associated with which score.
#'  2. `tf`: Source nodes of `network`.
#'  3. `condition`: Condition representing each column of `mat`.
#'  4. `score`: Regulatory activity (enrichment score).
#'  5. `statistic_time`: Internal execution time indicator.
#'  6. `...`: Columns of metadata generated by certain statistics.
#' @export
#' @import purrr
decouple <- function(mat,
                     network,
                     .source,
                     .target,
                     statistics,
                     .options = list(NULL),
                     verbose = FALSE) {

  # Match statistics to couple ----------------------------------------------

  available_statistics <- list(
    mean = expr(run_mean),
    scira = expr(run_scira),
    pscira = expr(run_pscira),
    viper = expr(run_viper),
    gsva = expr(run_gsva)
  )

  statistics <- statistics %>%
    match.arg(names(available_statistics), several.ok = TRUE) %>%
    available_statistics[.] %>%
    unname()

  # Evaluate statistics -----------------------------------------------------

  # For the moment this will only ensure that the parameters passed
  # to decoupleR are the same when invoking the functions.
  map2_dfr(
    .x = statistics,
    .y = .options,
    .f = .decouple_statistic_invoke,
    mat = mat,
    network = network,
    .source = {{ .source }},
    .target = {{ .target }},
    verbose = verbose,
    .id = "run_id"
  ) %>%
    select(
      .data$run_id,
      .data$statistic,
      .data$tf,
      .data$condition,
      .data$score,
      .data$statistic_time,
      everything()
    )
}

# Helpers -----------------------------------------------------------------
#' Construct an expression to evaluate a decoupleR statistic.
#'
#' @inheritParams decouple
#' @param fn Expression containing the name of the function to execute.
#' @param args Extra arguments to pass to the statistician under evaluation.
#'
#' @keywords internal
#' @noRd
.decouple_statistic_invoke <- function(fn, args, mat, network, .source, .target, verbose = FALSE) {
  .call <- expr(
    (!!fn)(
      mat = mat,
      network = network,
      .source = {{ .source }},
      .target = {{ .target }},
      !!!args)
  )

  if(verbose) {
    rlang::inform(rlang::qq_show(!!.call))
  }

  eval(.call)
}
