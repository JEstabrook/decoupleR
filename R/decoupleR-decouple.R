#' decouple
#'
#' Calculate the TF activity per sample out of a gene expression matrix by
#' coupling a regulon network with a variety of statistics.
#'
#' @inheritParams .decoupler_mat_format
#' @inheritParams .decoupler_network_format
#' @param statistics Statistical methods to be coupled.
#' @param args A list of argument-lists the same length as `statistics` (or length 1).
#'  The default argument, list(NULL), will be recycled to the same length as `statistics`,
#'  and will call each function with no arguments (apart from `mat`,
#'  `network`, `.source` and, `.target`).
#' @param show_call The call of each statistic must be informed?
#'
#' @return A long format tibble of the enrichment scores for each tf
#'  across the samples. Resulting tibble contains the following columns:
#'  1. `statistic`: Indicates which method is associated with which score.
#'  2. `tf`: Source nodes of `network`.
#'  3. `condition`: Condition representing each column of `mat`.
#'  4. `score`: Regulatory activity (enrichment score).
#'  5. `statistic_time`: Internal execution time indicator.
#'  6. `...`: Columns of metadata generated by certain statistics.
#' @export
#' @import purrr
decouple <- function(mat,
                     network,
                     .source,
                     .target,
                     statistics,
                     args = list(NULL),
                     show_call = FALSE) {

  # Match statistics to couple ----------------------------------------------

  available_statistics <- list(
    mean = expr(run_mean),
    scira = expr(run_scira),
    pscira = expr(run_pscira),
    viper = expr(run_viper),
    gsva = expr(run_gsva)
  )

  statistics <- statistics %>%
    match.arg(names(available_statistics), several.ok = TRUE) %>%
    available_statistics[.] %>%
    unname()

  # Evaluate statistics -----------------------------------------------------

  # For the moment this will only ensure that the parameters passed
  # to decoupleR are the same when invoking the functions.
  map2_dfr(
    .x = statistics,
    .y = args,
    .f = .invoke_statistic,
    mat = mat,
    network = network,
    .source = {{ .source }},
    .target = {{ .target }},
    show_call = show_call,
    .id = "run_id"
  ) %>%
    select(
      .data$run_id,
      .data$statistic,
      .data$tf,
      .data$condition,
      .data$score,
      .data$statistic_time,
      everything()
    )
}

# Helpers -----------------------------------------------------------------
#' Construct an expression to evaluate a decoupleR statistic.
#'
#' @details
#' `.invoke_statistic()` was designed because [purrr::invoke_map_dfr()] is retired.
#' The alternative proposed by the developers by purrr is to use [rlang::exec()] in
#' combination with [purrr::map2()], however, the function is not a quoting function,
#' so the parameters that require the `curly-curly` (`{{}}`) operator require a
#' special pre-processing. In practical terms, creating an expression of zero allows
#' us to have better control over the function call as suggested in the [rlang::exec()]
#' documentation. For instance, we can see how the function itself is being called.
#' Therefore, if an error occurs in one of the statistics, we will have a direct
#' traceback to the problematic call, as opposed to what happens directly using [rlang::exec()].
#'
#' @inheritParams decouple
#' @param fn Expression containing the name of the function to execute.
#' @param args Extra arguments to pass to the statistician under evaluation.
#'
#' @keywords internal
.invoke_statistic <- function(fn, args, mat, network, .source, .target, show_call = FALSE) {
  .call <- expr(
    (!!fn)(
      mat = mat,
      network = network,
      .source = {{ .source }},
      .target = {{ .target }},
      !!!args)
  )

  if(show_call) {
    rlang::inform(rlang::qq_show(!!.call))
  }

  eval(.call)
}
