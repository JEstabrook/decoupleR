
#' SAFE MEAN
#'
#' This function calculates the regulon activity of one sample by calculating
#' the mean over the expression of all regulon genes.
#'
#' @param FLS_vect A vector that contains the gene expression values of a sample.
#' @param FSC A nested list containing information about the regulons. For each
#' regulon it must contain MEMBERS, CONTRIBUTION, MOR, CONFIDENCE. A gene set
#' resource can be transformed into that format using the function df_to_list.
#' @param mixed Logical, if TRUE permutations are performed only within the
#' positive and negative values. Default is FALSE.
#' @param null_model Define a null model. If NULL (default) the null model is
#' generated by the permutations.
#' @param nperm A number that defines how many permutations are performed.
#' @param minsize A number that specifies the minimum number of genes that have
#' to be assigned to a regulon. Regulons with less genes are removed and not
#' included in the analysis.
#'
#' @return A matrix of enrichment scores for each gene set across all
#'  samples.
#'
#' @export
#'

SAFE_mean = function(FLS_vect, FSC, mixed = FALSE,
                     null_model = NULL,
                     nperm=3,minsize=4){



  ################################################################################
  FLS_vect = sort(FLS_vect,decreasing = T)
  FSC = clean_FSC(FLS_vect, FSC, minsize = minsize)
  # Getting the elements that are used
  target_features = unique(unlist(lapply(FSC, function(x) x$MEMBERS),
                                  use.names = FALSE))
  ################################################################################

  # Defining the FLS random matrix - This should be the slowest part - MUST INCLUDE everything
  # The more T-values, the better.

  ########################################
  if(is.null(null_model)){

    FLS_mat = t(matrix(FLS_vect,nrow = length(FLS_vect),ncol = nperm + 1))

    if(mixed){
      #Basically here we only permute positive values with positive, and negative with negative

      down_frontier = min(which(FLS_vect<0)) #First down index
      up_frontier = down_frontier - 1 #Last up index

      FLS_mat_mixed = FLS_mat

      FLS_mat_mixed[2:nrow(FLS_mat),1:up_frontier] = apply(FLS_mat_mixed[2:nrow(FLS_mat),1:up_frontier],1,sample)

      FLS_mat_mixed[2:nrow(FLS_mat),down_frontier:ncol(FLS_mat)] = apply(FLS_mat_mixed[2:nrow(FLS_mat),down_frontier:ncol(FLS_mat)],
                                                                         1,sample)
      colnames(FLS_mat_mixed) = names(FLS_vect)

      FLS_mat_mixed = FLS_mat_mixed[,colnames(FLS_mat_mixed) %in% target_features]
    }

    FLS_mat[2:nrow(FLS_mat),] = apply(FLS_mat[2:nrow(FLS_mat),],1,sample)

    colnames(FLS_mat) = names(FLS_vect)

    FLS_mat = FLS_mat[,colnames(FLS_mat) %in% target_features]

  }
  ################################################################################

  # Defining the GSC matrix
  ########################################
  MOR_mat = get_MORmatrix(FSC,target_features)
  CONTRIBUTION_mat = get_CONTmatrix(FSC,target_features)

  FSC_matrix = MOR_mat * CONTRIBUTION_mat
  FSC_matrix = t(t(FSC_matrix)/colSums(CONTRIBUTION_mat))
  #sum(FSC_matrix[,"HIF1A-high-RegNetwork"])

  #FSC_matrix = get_FSCmatrix(FSC,target_features)
  #sum(FSC_matrix[,"HIF1A-high-RegNetwork"])

  FSC_matrix = FSC_matrix[colnames(FLS_mat),]

  # Calculation of ESs
  ########################################

  ES_matrix_directional = FLS_mat %*% FSC_matrix
  ES_matrix_nondirectional = abs(FLS_mat) %*% abs(FSC_matrix)

  ES_directional = ES_matrix_directional[1,]
  ES_nondirectional = ES_matrix_nondirectional[1,]


  ########################################

  # Calculation of significance
  ########################################
  p_value_directional = apply(ES_matrix_directional,2,function(ES_vect){
    ES = ES_vect[1]
    NULL_ES = ES_vect[-1]
    pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
  })

  p_value_nondirectional = apply(ES_matrix_nondirectional,2,function(ES_vect){
    ES = ES_vect[1]
    NULL_ES = ES_vect[-1]
    pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
  })

  # Creation of result data frame
  ########################################

  size_vect = sapply(FSC,function(x) length(x$MEMBERS))
  ix_re = names(size_vect)


  Directional_DF = tibble(SetName = ix_re, SetSize = size_vect[ix_re],
                          ES = ES_directional[ix_re], p_value = p_value_directional[ix_re]) %>% plyr::arrange(p_value,desc(ES))

  nonDirectional_DF = tibble(SetName = ix_re, SetSize = size_vect[ix_re],
                             ES = ES_nondirectional[ix_re], p_value = p_value_nondirectional[ix_re]) %>% plyr::arrange(p_value,desc(ES))

  ResultsList = list("directional" = Directional_DF, "non_directional" = nonDirectional_DF)

  # If mixed directionality
  ########################################

  if(mixed){

    MOR_matrix_mixdown = MOR_matrix_mixup = MOR_mat * sign(FLS_vect[rownames(MOR_mat)])

    MOR_matrix_mixup[MOR_matrix_mixup<0] = 0
    MOR_matrix_mixdown[MOR_matrix_mixup>0] = 0

    mixup_size = colSums(MOR_matrix_mixup!=0)
    mixdown_size = colSums(MOR_matrix_mixdown!=0)

    ix_up_col = which(mixup_size >= minsize)
    ix_down_col = which(mixdown_size >= minsize)

    if(length(ix_up_col)>0){

      mixup_sets = names(mixup_size[ix_up_col])

      MOR_matrix_mixup[as.logical(MOR_matrix_mixup)] = MOR_mat[as.logical(MOR_matrix_mixup)]
      MOR_matrix_mixup = MOR_matrix_mixup[which(rowSums(MOR_matrix_mixup)!=0),mixup_sets]

      #MOR_matrix_mixup = MOR_matrix_mixup * MOR_mat[rownames(MOR_matrix_mixup),colnames(MOR_matrix_mixup)]

      CONT_matrix_mixup = CONTRIBUTION_mat[rownames(MOR_matrix_mixup),colnames(MOR_matrix_mixup)]

      FSC_matrix_mixup = MOR_matrix_mixup * CONT_matrix_mixup
      FSC_matrix_mixup = t(t(FSC_matrix_mixup)/colSums(CONT_matrix_mixup))

      ES_matrix_mixup = FLS_mat_mixed[,rownames(FSC_matrix_mixup)] %*% FSC_matrix_mixup

      ES_mixup = ES_matrix_mixup[1,]

      p_value_mixup = apply(ES_matrix_mixup,2,function(ES_vect){
        ES = ES_vect[1]
        NULL_ES = ES_vect[-1]
        pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
      })

      #ix_re = names(mixup_size[mixup_sets])

      mixup_DF = tibble(SetName = mixup_sets, SetSize = mixup_size[mixup_sets],
                        ES = ES_mixup[mixup_sets], p_value = p_value_mixup[mixup_sets]) %>% plyr::arrange(p_value,desc(ES))

      ResultsList[["mixup"]] = mixup_DF

    }

    if(length(ix_down_col)>0){

      mixdown_sets = names(mixdown_size[ix_down_col])

      MOR_matrix_mixdown[as.logical(abs(MOR_matrix_mixdown))] = MOR_mat[as.logical(abs(MOR_matrix_mixdown))]
      MOR_matrix_mixdown = MOR_matrix_mixdown[which(rowSums(MOR_matrix_mixdown)!=0),mixdown_sets]
      #MOR_matrix_mixdown = MOR_matrix_mixdown * MOR_mat[rownames(MOR_matrix_mixdown),colnames(MOR_matrix_mixdown)]
      CONT_matrix_mixdown = CONTRIBUTION_mat[rownames(MOR_matrix_mixdown),colnames(MOR_matrix_mixdown)]

      FSC_matrix_mixdown = MOR_matrix_mixdown * CONT_matrix_mixdown
      FSC_matrix_mixdown = t(t(FSC_matrix_mixdown)/colSums(CONT_matrix_mixdown))

      ES_matrix_mixdown = FLS_mat_mixed[,rownames(FSC_matrix_mixdown)] %*% FSC_matrix_mixdown

      ES_mixdown = ES_matrix_mixdown[1,]

      p_value_mixdown = apply(ES_matrix_mixdown,2,function(ES_vect){
        ES = ES_vect[1]
        NULL_ES = ES_vect[-1]
        pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
      })

      #ix_re = names(mixup_size[mixup_sets])

      mixdown_DF = tibble(SetName = mixdown_sets, SetSize = mixdown_size[mixdown_sets],
                          ES = ES_mixdown[mixdown_sets], p_value = p_value_mixdown[mixdown_sets]) %>% plyr::arrange(p_value,ES)

      ResultsList[["mixdown"]] = mixdown_DF

    }


  }


  ########################################

  return(ResultsList)
}


##################################################################################################

#' SAFE MEAN normalized
#'
#' This function calculates the regulon activity of one sample by calculating
#' a normalized mean using the z-scores.
#'
#' @param FLS_vect A vector that contains the gene expression values of a sample.
#' @param FSC A nested list containing information about the regulons. For each
#' regulon it must contain MEMBERS, CONTRIBUTION, MOR, CONFIDENCE. A gene set
#' resource can be transformed into that format using the function df_to_list.
#' @param mixed Logical, if TRUE permutations are performed only within the
#' positive and negative values. Default is FALSE.
#' @param null_model Define a null model. If NULL (default) the null model is
#' generated by the permutations.
#' @param nperm A number that defines how many permutations are performed.
#' @param minsize A number that specifies the minimum number of genes that have
#' to be assigned to a regulon. Regulons with less genes are removed and not
#' included in the analysis.
#'
#' @return A matrix of normalized enrichment scores for each gene set across all
#'  samples.
#'
#' @export
#'

SAFE_mean_normalized = function(FLS_vect, FSC, mixed = FALSE,
                                null_model = NULL,
                                nperm=100, minsize=4){



  ################################################################################
  FLS_vect = sort(FLS_vect,decreasing = T)
  FSC = clean_FSC(FLS_vect, FSC, minsize = minsize)
  # Getting the elements that are used
  target_features = unique(unlist(lapply(FSC, function(x) x$MEMBERS),
                                  use.names = FALSE))
  ################################################################################

  # Defining the FLS random matrix - This should be the slowest part - MUST INCLUDE everything
  # The more T-values, the better.

  ########################################
  if(is.null(null_model)){

    FLS_mat = t(matrix(FLS_vect,nrow = length(FLS_vect),ncol = nperm + 1))

    if(mixed){
      #Basically here we only permute positive values with positive, and negative with negative

      down_frontier = min(which(FLS_vect<0)) #First down index
      up_frontier = down_frontier - 1 #Last up index

      FLS_mat_mixed = FLS_mat

      FLS_mat_mixed[2:nrow(FLS_mat),1:up_frontier] = apply(FLS_mat_mixed[2:nrow(FLS_mat),1:up_frontier],1,sample)

      FLS_mat_mixed[2:nrow(FLS_mat),down_frontier:ncol(FLS_mat)] = apply(FLS_mat_mixed[2:nrow(FLS_mat),down_frontier:ncol(FLS_mat)],
                                                                         1,sample)
      colnames(FLS_mat_mixed) = names(FLS_vect)

      FLS_mat_mixed = FLS_mat_mixed[,colnames(FLS_mat_mixed) %in% target_features]
    }

    FLS_mat[2:nrow(FLS_mat),] = apply(FLS_mat[2:nrow(FLS_mat),],1,sample)

    colnames(FLS_mat) = names(FLS_vect)

    FLS_mat = FLS_mat[,colnames(FLS_mat) %in% target_features]

  }
  ################################################################################

  # Defining the GSC matrix
  ########################################
  MOR_mat = get_MORmatrix(FSC,target_features)
  CONTRIBUTION_mat = get_CONTmatrix(FSC,target_features)

  FSC_matrix = MOR_mat * CONTRIBUTION_mat
  FSC_matrix = t(t(FSC_matrix)/colSums(CONTRIBUTION_mat))
  #sum(FSC_matrix[,"HIF1A-high-RegNetwork"])

  #FSC_matrix = get_FSCmatrix(FSC,target_features)
  #sum(FSC_matrix[,"HIF1A-high-RegNetwork"])

  FSC_matrix = FSC_matrix[colnames(FLS_mat),]

  # Calculation of ESs
  ########################################

  ES_matrix_directional = FLS_mat %*% FSC_matrix
  ES_matrix_nondirectional = abs(FLS_mat) %*% abs(FSC_matrix)

  ES_directional = ES_matrix_directional[1,]
  ES_nondirectional = ES_matrix_nondirectional[1,]


  ########################################

  # Calculation of z-scores
  ########################################
  z_scores_directional = apply(ES_matrix_directional,2,function(ES_vect){
    ES = ES_vect[1]
    NULL_ES = ES_vect[-1]

    z_score = (ES - mean(NULL_ES))/sd(NULL_ES)
  })

  z_scores_nondirectional = apply(ES_matrix_nondirectional,2,function(ES_vect){
    ES = ES_vect[1]
    NULL_ES = ES_vect[-1]

    z_score = (ES - mean(NULL_ES))/sd(NULL_ES)
  })



  # Creation of result data frame
  ########################################

  size_vect = sapply(FSC,function(x) length(x$MEMBERS))
  ix_re = names(size_vect)


  Directional_DF = tibble(SetName = ix_re, SetSize = size_vect[ix_re],
                          ES = z_scores_directional[ix_re])

  nonDirectional_DF = tibble(SetName = ix_re, SetSize = size_vect[ix_re],
                             ES = z_scores_nondirectional[ix_re])

  ResultsList = list("directional" = Directional_DF, "non_directional" = nonDirectional_DF)

  # If mixed directionality
  ########################################

  if(mixed){

    MOR_matrix_mixdown = MOR_matrix_mixup = MOR_mat * sign(FLS_vect[rownames(MOR_mat)])

    MOR_matrix_mixup[MOR_matrix_mixup<0] = 0
    MOR_matrix_mixdown[MOR_matrix_mixup>0] = 0

    mixup_size = colSums(MOR_matrix_mixup!=0)
    mixdown_size = colSums(MOR_matrix_mixdown!=0)

    ix_up_col = which(mixup_size >= minsize)
    ix_down_col = which(mixdown_size >= minsize)

    if(length(ix_up_col)>0){

      mixup_sets = names(mixup_size[ix_up_col])

      MOR_matrix_mixup[as.logical(MOR_matrix_mixup)] = MOR_mat[as.logical(MOR_matrix_mixup)]
      MOR_matrix_mixup = MOR_matrix_mixup[which(rowSums(MOR_matrix_mixup)!=0),mixup_sets]

      #MOR_matrix_mixup = MOR_matrix_mixup * MOR_mat[rownames(MOR_matrix_mixup),colnames(MOR_matrix_mixup)]

      CONT_matrix_mixup = CONTRIBUTION_mat[rownames(MOR_matrix_mixup),colnames(MOR_matrix_mixup)]

      FSC_matrix_mixup = MOR_matrix_mixup * CONT_matrix_mixup
      FSC_matrix_mixup = t(t(FSC_matrix_mixup)/colSums(CONT_matrix_mixup))

      ES_matrix_mixup = FLS_mat_mixed[,rownames(FSC_matrix_mixup)] %*% FSC_matrix_mixup

      ES_mixup = ES_matrix_mixup[1,]

      p_value_mixup = apply(ES_matrix_mixup,2,function(ES_vect){
        ES = ES_vect[1]
        NULL_ES = ES_vect[-1]
        pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
      })

      #ix_re = names(mixup_size[mixup_sets])

      mixup_DF = tibble(SetName = mixup_sets, SetSize = mixup_size[mixup_sets],
                        ES = ES_mixup[mixup_sets], p_value = p_value_mixup[mixup_sets]) %>% plyr::arrange(p_value,desc(ES))

      ResultsList[["mixup"]] = mixup_DF

    }

    if(length(ix_down_col)>0){

      mixdown_sets = names(mixdown_size[ix_down_col])

      MOR_matrix_mixdown[as.logical(abs(MOR_matrix_mixdown))] = MOR_mat[as.logical(abs(MOR_matrix_mixdown))]
      MOR_matrix_mixdown = MOR_matrix_mixdown[which(rowSums(MOR_matrix_mixdown)!=0),mixdown_sets]
      #MOR_matrix_mixdown = MOR_matrix_mixdown * MOR_mat[rownames(MOR_matrix_mixdown),colnames(MOR_matrix_mixdown)]
      CONT_matrix_mixdown = CONTRIBUTION_mat[rownames(MOR_matrix_mixdown),colnames(MOR_matrix_mixdown)]

      FSC_matrix_mixdown = MOR_matrix_mixdown * CONT_matrix_mixdown
      FSC_matrix_mixdown = t(t(FSC_matrix_mixdown)/colSums(CONT_matrix_mixdown))

      ES_matrix_mixdown = FLS_mat_mixed[,rownames(FSC_matrix_mixdown)] %*% FSC_matrix_mixdown

      ES_mixdown = ES_matrix_mixdown[1,]

      p_value_mixdown = apply(ES_matrix_mixdown,2,function(ES_vect){
        ES = ES_vect[1]
        NULL_ES = ES_vect[-1]
        pval = sum(abs(NULL_ES) > abs(ES))/length(NULL_ES)
      })

      #ix_re = names(mixup_size[mixup_sets])

      mixdown_DF = tibble(SetName = mixdown_sets, SetSize = mixdown_size[mixdown_sets],
                          ES = ES_mixdown[mixdown_sets], p_value = p_value_mixdown[mixdown_sets]) %>% plyr::arrange(p_value,ES)

      ResultsList[["mixdown"]] = mixdown_DF

    }


  }


  ########################################

  return(ResultsList)
}


#' Helper function
#'
#' @param FLS_vect A vector that contains the gene expression values of a sample.
#' @param FSC A nested list containing information about the regulons. For each
#' regulon it must contain MEMBERS, CONTRIBUTION, MOR, CONFIDENCE. A gene set
#' resource can be transformed into that format using the function df_to_list.
#' @param minsize A number that specifies the minimum number of genes that have
#' to be assigned to a regulon. Regulons with less genes are removed and not
#' included in the analysis.
#'
#' @return A nested list of regulons filtered according to minsize.

clean_FSC = function(FLS_vect, FSC, minsize = 4){
  FSC = lapply(FSC, function(x, genes) {
    pos = x$MEMBERS %in% genes
    list(MEMBERS = x$MEMBERS[pos], CONTRIBUTION = x$CONTRIBUTION[pos],
         MOR = x$MOR[pos], CONFIDENCE = x$CONFIDENCE)
  }, genes = names(FLS_vect))

  FSC = FSC[sapply(FSC, function(x) length(x$MEMBERS)) >= minsize]

  return(FSC)
}

#' Helper function
#'
#' @param FSC A nested list containing information about the regulons. For each
#' regulon it must contain MEMBERS, CONTRIBUTION, MOR, CONFIDENCE. A gene set
#' resource can be transformed into that format using the function df_to_list.
#' @param target_features A vector including the target genes of a tf.
#'
#' @return A matrix including the mode of regulation of a tf on its targets
get_MORmatrix = function(FSC,target_features){
  FSC_mat = sapply(FSC, function(x, genes) {
    ix = fastmatch::fmatch(genes, x$MEMBERS)
    return(x$MOR[ix])
  }, genes = target_features)

  rownames(FSC_mat) = target_features

  FSC_mat[is.na(FSC_mat)] = 0
  return(FSC_mat)
}

#' Helper function
#'
#' @param FSC A nested list containing information about the regulons. For each
#' regulon it must contain MEMBERS, CONTRIBUTION, MOR, CONFIDENCE. A gene set
#' resource can be transformed into that format using the function df_to_list.
#' @param target_features A vector including the target genes of a tf.
#'
#' @return A matrix including the contribution of a tf on its targets
get_CONTmatrix = function(FSC,target_features){
  FSC_mat = sapply(FSC, function(x, genes) {
    ix = fastmatch::fmatch(genes, x$MEMBERS)
    return(x$CONTRIBUTION[ix])
  }, genes = target_features)

  rownames(FSC_mat) = target_features

  FSC_mat[is.na(FSC_mat)] = 0
  return(FSC_mat)
}
